[{"categories":["All","Professional"],"content":"Some problems that I solved. Note\r\rAll the problems will be at this repo.\r\r ","date":"2021-08-29","objectID":"/problemsolving/:0:0","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Day 01 ","date":"2021-08-29","objectID":"/problemsolving/:1:0","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"array left rotation ''' CS21-Science-Day-1 name: Mahmoud Abdallah Hassan task: array left rotation link: https://www.hackerrank.com/challenges/array-left-rotation/problem ''' import math import os import random import re import sys # # Complete the 'rotateLeft' function below. # # The function is expected to return an INTEGER_ARRAY. # The function accepts following parameters: # 1. INTEGER d # 2. INTEGER_ARRAY arr # def rotateLeft(d, arr): # Write your code here for i in range(d): arr.append(arr[i]) for i in range(d): arr.remove(arr[0]) return arr if __name__ == '__main__': #fptr = open(os.environ['OUTPUT_PATH'], 'w') first_multiple_input = input().rstrip().split() n = int(first_multiple_input[0]) d = int(first_multiple_input[1]) arr = list(map(int, input().rstrip().split())) result = rotateLeft(d, arr) print(' '.join(map(str, result))) input('press enter to exit...') # fptr.write(' '.join(map(str, result))) # fptr.write('\\n') # fptr.close() ","date":"2021-08-29","objectID":"/problemsolving/:1:1","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Day 02 ","date":"2021-08-29","objectID":"/problemsolving/:2:0","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Find merge point in two list # find merge point in two list #!/bin/python3 import math import os import random import re import sys class SinglyLinkedListNode: def __init__(self, node_data): self.data = node_data self.next = None class SinglyLinkedList: def __init__(self): self.head = None self.tail = None def insert_node(self, node_data): node = SinglyLinkedListNode(node_data) if not self.head: self.head = node else: self.tail.next = node self.tail = node def print_singly_linked_list(node, sep, fptr): while node: fptr.write(str(node.data)) node = node.next if node: fptr.write(sep) def findMergeNode(head1, head2): # func to get the count def getcount(head): c = 0 while head.next != None: head = head.next c+=1 return c # func to get the node def getNode(dif, head1, head2): # iter. up to dif for i in range(dif): head1 = head1.next while head1 and head2: if head1 == head2: return head1.data else: head1 = head1.next head2 = head2.next c1 = getcount(head1) c2 = getcount(head2) # check the difference if c1 \u003e c2: return getNode(c1 - c2, head1, head2) else: return getNode(c2 - c1, head2, head1) if __name__ == '__main__': # fptr = open(os.environ['OUTPUT_PATH'], 'w') tests = int(input()) for tests_itr in range(tests): index = int(input()) llist1_count = int(input()) llist1 = SinglyLinkedList() for _ in range(llist1_count): llist1_item = int(input()) llist1.insert_node(llist1_item) llist2_count = int(input()) llist2 = SinglyLinkedList() for _ in range(llist2_count): llist2_item = int(input()) llist2.insert_node(llist2_item) ptr1 = llist1.head; ptr2 = llist2.head; for i in range(llist1_count): if i \u003c index: ptr1 = ptr1.next for i in range(llist2_count): if i != llist2_count-1: ptr2 = ptr2.next ptr2.next = ptr1 result = findMergeNode(llist1.head, llist2.head) print(result) # fptr.write(str(result) + '\\n') # fptr.close() ","date":"2021-08-29","objectID":"/problemsolving/:2:1","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Day 03 ","date":"2021-08-29","objectID":"/problemsolving/:3:0","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Registration System # # name: Mahmoud Abdallah Hassan # link: https://codeforces.com/contest/4/problem/C # # time complexity: O(n) if __name__ == \"__main__\": n = int(input()) database = {} for i in range(n): username = input() # check if username is in the dictionary if username in database: # note that the value of non-found username is none, So there will be no value. print(username+str(database[username])) database[username] += 1 else: print(\"OK\") database[username] = 1 ","date":"2021-08-29","objectID":"/problemsolving/:3:1","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Day 04 ","date":"2021-08-29","objectID":"/problemsolving/:4:0","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"cycle Detection # # CS21-Science-Day-05 # name: Mahmoud Abdallah # task: cycle detection # link: https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem # #!/bin/python3 import math import os import random import re import sys class SinglyLinkedListNode: def __init__(self, node_data): self.data = node_data self.next = None class SinglyLinkedList: def __init__(self): self.head = None self.tail = None def insert_node(self, node_data): node = SinglyLinkedListNode(node_data) if not self.head: self.head = node else: self.tail.next = node self.tail = node def print_singly_linked_list(node, sep, fptr): while node: fptr.write(str(node.data)) node = node.next if node: fptr.write(sep) # Complete the has_cycle function below. # # For your reference: # # SinglyLinkedListNode: # int data # SinglyLinkedListNode next # # def has_cycle(head): # idea to create two pointers, make the logic and finially check if the two pointers are the same # note that head is a pointer pointer2 = pointer1 = head # make sure that the linkedlist is not empty or having a single node (in that case there will not be a cylce to detect) while pointer1 != None and pointer1.next != None: # set pointers pointer1 = pointer1.next.next pointer2 = pointer2.next # check if the two pointers are same if pointer1 == pointer2: return True return False if __name__ == '__main__': fptr = open(os.environ['OUTPUT_PATH'], 'w') tests = int(input()) for tests_itr in range(tests): index = int(input()) llist_count = int(input()) llist = SinglyLinkedList() for _ in range(llist_count): llist_item = int(input()) llist.insert_node(llist_item) extra = SinglyLinkedListNode(-1) temp = llist.head for i in range(llist_count): if i == index: extra = temp if i != llist_count-1: temp = temp.next temp.next = extra result = has_cycle(llist.head) print(str(int(result))) fptr.write(str(int(result)) + '\\n') fptr.close() ","date":"2021-08-29","objectID":"/problemsolving/:4:1","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Day 05 ","date":"2021-08-29","objectID":"/problemsolving/:5:0","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Flipping the matrix # # CS21-Science-Day-05 # name: Mahmoud Abdallah # task: Flipping the Matrix # link: https://www.hackerrank.com/challenges/flipping-the-matrix/problem?isFullScreen=false # #!/bin/python3 import math import os import random import re import sys # Complete the flippingMatrix function below. def flippingMatrix(matrix): n = len(matrix[0]) for i in range(n): for j in range(n): print(sum([max(matrix[i][j]), matrix[i][2*n - 1 - j], matrix[2*n - 1 - i][j], matrix[2*n -1 -i][2*n -1 -j]])) if __name__ == '__main__': fptr = open(os.environ['OUTPUT_PATH'], 'w') q = int(input()) for q_itr in range(q): n = int(input()) matrix = [] for _ in range(2*n): # row by row; each row is a list matrix.append(list(map(int, input().rstrip().split()))) result = flippingMatrix(matrix) print(str(result)) fptr.write(str(result) + '\\n') fptr.close() ","date":"2021-08-29","objectID":"/problemsolving/:5:1","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Day 06 ","date":"2021-08-29","objectID":"/problemsolving/:6:0","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Tree Huffman Decoding import queue as Queue cntr = 0 class Node: def __init__(self, freq, data): self.freq = freq self.data = data self.left = None self.right = None global cntr self._count = cntr cntr = cntr + 1 def __lt__(self, other): if self.freq != other.freq: return self.freq \u003c other.freq return self._count \u003c other._count def huffman_hidden():#builds the tree and returns root q = Queue.PriorityQueue() for key in freq: q.put((freq[key], key, Node(freq[key], key) )) while q.qsize() != 1: a = q.get() b = q.get() obj = Node(a[0] + b[0], '\\0' ) obj.left = a[2] obj.right = b[2] q.put((obj.freq, obj.data, obj )) root = q.get() root = root[2]#contains root object return root def dfs_hidden(obj, already): if(obj == None): return elif(obj.data != '\\0'): code_hidden[obj.data] = already dfs_hidden(obj.right, already + \"1\") dfs_hidden(obj.left, already + \"0\") \"\"\"class Node: def __init__(self, freq,data): self.freq= freq self.data=data self.left = None self.right = None \"\"\" # Enter your code here. Read input from STDIN. Print output to STDOUT def decodeHuff(root, s): #Enter Your Code Here temp = root result = [] # traverse on string for char in s: if char == \"1\": temp = temp.right else: temp = temp.left # check if there is a leaf node if temp.left is None and temp.right is None: result.append(temp.data) temp = root print(''.join(result)) ip = input() freq = {}#maps each character to its frequency cntr = 0 for ch in ip: if(freq.get(ch) == None): freq[ch] = 1 else: freq[ch]+=1 root = huffman_hidden()#contains root of huffman tree code_hidden = {}#contains code for each object dfs_hidden(root, \"\") if len(code_hidden) == 1:#if there is only one character in the i/p for key in code_hidden: code_hidden[key] = \"0\" toBeDecoded = \"\" for ch in ip: toBeDecoded += code_hidden[ch] decodeHuff(root, toBeDecoded) ","date":"2021-08-29","objectID":"/problemsolving/:6:1","series":null,"tags":["Problem Solving"],"title":"Problem Solving","uri":"/problemsolving/"},{"categories":["All","Professional"],"content":"Note\r\rAll my notes are going to be on My Github Account\r\r Grokking Algorithms ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:0:0","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Chapter 01 ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:1:0","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Introduction to algorithms Chapter 01: Introduction to algorithms Some common Big O run times sorted from fastest to slowest: • O(log n), also known as log time. Example: Binary search. • O(n), also known as linear time. Example: Simple search. • O(n * log n). Example: A fast sorting algorithm, like quicksort. • O(n2). Example: A slow sorting algorithm, like selection sort. • O(n!). Example: A really slow algorithm, like the traveling Salesperson. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:1:1","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Recap • Binary search is a lot faster than simple search. • O(log n) is faster than O(n), but it gets a lot faster once the list of items you’re searching through grows. • Algorithm speed isn’t measured in seconds. • Algorithm times are measured in terms of growth of an algorithm. • Algorithm times are written in Big O notation. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:1:2","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Chapter 02 ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:2:0","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Selection Sort Chapter 02: Selection Sort • Linked lists are great if you’re going to read all the items one at a time. • Arrays are great if you want to read random elements. • Lists are better if you want to insert elements into the middle. • A lot of use cases require random access, so arrays are used a lot. Arrays and lists are used to implement other data structures. • Selection sort is a neat algorithm, but it’s not very fast. Quicksort is a faster sorting algorithm that only takes O(n log n) time. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:2:1","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Recap • When you want to store multiple elements, use an array or a list. • With an array, all your elements are stored right next to each other. • With a list, elements are strewn all over, and one element stores the address of the next one. • Arrays allow fast reads. • Linked lists allow fast inserts and deletes. • All elements in the array should be the same type (all ints, all doubles, and so on). # A simple Selection sort Algorithm def findSmallest(arr): smallest = arr[0] smallest_index = 0 for i in range(1, len(arr)): if arr[i] \u003c smallest: smallest =arr[i] smallest_index = i return smallest_index def selectionSort(arr): new_arr = [] for i in range(len(arr)): smallest = findSmallest(arr) new_arr.append(arr.pop(smallest)) return new_arr if __name__ == '__main__': arr = list(map(int, input().split())) print(selectionSort(arr)) ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:2:2","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Chapter 03 ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:3:0","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Recursion Chapter 03: Recursion Pseudocode is a high-level description of the problem you’re trying to solve, in code. It’s written like code, but it’s meant to be closer to human speech. Recursion is where a function calls itself. Quote by Leigh Caldwell on Stack Overflow: “Loops may achieve a performance gain for your program. Recursion may achieve a performance gain for your programmer. Choose which is more important in your situation!” every recursive function has two parts: the base case, and the recursive case. Using the stack is convenient because you don’t have to keep track of a pile of boxes yourself—the stack does it for you. but there’s a cost: saving all that info can take up a lot of memory. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:3:1","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Recap • Recursion is when a function calls itself. • Every recursive function has two cases: the base case and the recursive case. • A stack has two operations: push and pop. • All function calls go onto the call stack. • The call stack can get very large, which takes up a lot of memory. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:3:2","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Chapter 04 ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:4:0","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Quicksort Chapter 04: Quicksort • Quicksort is a sorting algorithm, and a much faster one than selection sort. • To solve a problem using D\u0026C, there are two steps: 1. Figure out the base case. This should be the simplest possible case. 2. Divide or decrease your problem until it becomes the base case. • Remember, recursion keeps track of the state. • When you’re writing a recursive function involving an array, the base case is often an empty array or an array with one element. If you’re stuck, try that first. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:4:1","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Recap • D\u0026C works by breaking a problem down into smaller and smaller pieces. If you’re using D\u0026C on a list, the base case is probably an empty array or an array with one element. • If you’re implementing quicksort, choose a random element as the pivot. The average runtime of quicksort is O(n log n)! • The constant in Big O notation can matter sometimes. That’s why quicksort is faster than merge sort. • The constant almost never matters for simple search versus binary search, because O(log n) is so much faster than O(n) when your list gets big. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:4:2","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Chapter 05 ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:5:0","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Hash Tables Chapter 05: Hash Tables → Using hash tables for lookups Hash tables are great when you want to • Create a mapping from one thing to another thing. • Look something up. → Preventing duplicate entries. → Using hash tables as a cache you’d just remember and answer. This is how caching works: websites remember the data instead of recalculating it. When you visit a page on Facebook, it first checks whether the page is stored in the hash. cache = {} def get_page(url): if cache.get(url): return cache[url] # returned cached data else: data = get_data_from_server(url) cache[url] = data # saves this data in your cache first. return data Here, you make the server do work only if the URL isn’t in the cache. Before you return the data, though, you save it in the cache. The next time someone requests this URL, you can send the data from the cache instead of making the server do the work. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:5:1","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Recap To recap, hashes are good for • Modeling relationships from one thing to another thing. • Filtering out duplicates. • Caching/memorizing data instead of making your server do work. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:5:2","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Collisions Def: an event of two or more records being assigned the same identifier or location in memory. Simplest way to deal with collisions is this: if multiple keys map to the same slot, start a linked list at that slot. There is a problem here, The entire hash table is totally empty except for one slot. And that slot has a giant linked list! Every single element in this hash table is in the linked list. That’s as bad as putting everything in a linked list to begin with. It’s going to slow down your hash table. A good hash function will give you very few collisions. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:5:3","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Performance In the average case, hash tables take O(1) for everything. O(1) is called constant time. You haven’t seen constant time before. It doesn’t mean instant. It means the time taken will stay the same, regardless of how big the hash table is. It’s important that you don’t hit worst-case performance with hash tables. And to do that, you need to avoid collisions. To avoid collisions, you need: • A low load factor. • A good hash function. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:5:4","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Load factor Load factor measures how many empty slots remain in your hash table Having a load factor greater than 1 means you have more items than slots in your array. Once the load factor starts to grow, you need to add more slots to your hash table. This is called resizing. A good rule of thumb is, resize when your load factor is greater than 0.7. A good hash function: • A good hash function distributes values in the array evenly. • A bad hash function groups values together and produces a lot of collisions. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:5:5","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Recap You’ll almost never have to implement a hash table yourself. The programming language you use should provide an implementation for you. You can use Python’s hash tables and assume that you’ll get the average case performance: constant time. Hash tables are a powerful data structure because they’re so fast and they let you model data in a different way. You might soon find that you’re using them all the time: • You can make a hash table by combining a hash function with an array. • Collisions are bad. You need a hash function that minimizes collisions. • Hash tables have really fast search, insert, and delete. • Hash tables are good for modeling relationships from one item to another item. • Once your load factor is greater than .07, it’s time to resize your hash table. • Hash tables are used for caching data (for example, with a web server). • Hash tables are great for catching duplicates. ","date":"2021-08-27","objectID":"/notesforgrokkingalgorithms/:5:6","series":null,"tags":["Book Notes"],"title":"NotesForGrokkingAlgorithms","uri":"/notesforgrokkingalgorithms/"},{"categories":["All","Professional"],"content":"Note\r\rAll my notes are going to be on my github account My Github Account\r\r Clean Code book ","date":"2021-08-26","objectID":"/notesforcleancodebook/:0:0","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Professional"],"content":"Chapter 01 Note of Chapter one ","date":"2021-08-26","objectID":"/notesforcleancodebook/:1:0","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Professional"],"content":"Introduction 5:44 PM 11/23/2020 Name: mahmoud Abdallah Hassan Clean Code Book Chapter 01 Clean Code • code represents the details of the requirements. • specifying requirements in such detail that a machine can execute them is programming. Such a specification is code • But we will never eliminate necessary precision—so there will always be code. • It was the bad code that brought the company down. • If you are a programmer of any experience then you’ve felt this impediment many times. Indeed, we have a name for it. We call it wading. We • LeBlanc’s law: Later equals never. ‎ • No change is trivial. • Management does the only thing they can; they add more staff • (new staff): They don’t know the difference between a change that matches the design intent and a change that thwarts the design intent ","date":"2021-08-26","objectID":"/notesforcleancodebook/:1:1","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Professional"],"content":"The Grand Redesign in the Sky • The Grand Redesign in the Sky: Eventually Management bend to the demands of the developers and authorize the grand redesign in the sky. A new tiger team is selected. Now the two teams are in a race. Management will not replace the old system until the new system can do everything that the old system does. This race can go on for a very long time. (could take 10 years) the new system be redesigned because it’s such a mess. (moral): keeping your code clean is not just cost effective; it’s a matter of professional survival ","date":"2021-08-26","objectID":"/notesforcleancodebook/:1:2","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Professional"],"content":"Attitude • Attitude: We are unprofessional. This may be a bitter pill to swallow. (as programmers): we should not be shy about telling them what we think. It’s your job to defend the code with equal passion. (moral): it is unprofessional for programmers to bend to the will of managers who don’t understand the risks of making messes. • The Primal Conundrum: True professionals know that the second part of the conundrum is wrong. You will not make the deadline by making the mess. The only way to make the deadline—the only way to go fast—is to keep the code as clean as possible at all times. ","date":"2021-08-26","objectID":"/notesforcleancodebook/:1:3","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Professional"],"content":"The Art of Clean Code • The Art of Clean Code?: The bad news is that writing clean code is a lot like painting a picture. Most of us know when a picture is painted well or badly. But being able to recognize good art from bad does not mean that we know how to paint. So too being able to recognize clean code from dirty code does not mean that we know how to write clean code! Writing clean code requires the disciplined use of a myriad little techniques applied through a painstakingly acquired sense of “cleanliness.” This “code-sense” is the key. Some of us are born with it. Some of us have to fight to acquire it. Not only does it let us see whether code is good or bad, but it also shows us the strategy for applying our discipline to transform bad code into clean code. ","date":"2021-08-26","objectID":"/notesforcleancodebook/:1:4","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Professional"],"content":"What Is Clean Code • What Is Clean Code?: Bjarne Stroustrup quote Bjarne Stroustrup, inventor of C++ and author of The C++ Programming Language. \"like my code to be elegant and efficient. The logic should be straightforward to make it hard for bugs to hide, the dependencies minimal to ease maintenance, error handling complete according to an articulated strategy, and performance close to optimal so as not to tempt people to make the code messy with unprincipled optimizations. Clean code does one thing well.\" notes notes: • “elegant.” pleasingly graceful and stylish in appearance or manner; pleasingly ingenious and simple. • efficienc • “tempt.” Bad code tempts the mess to grow! • One broken window starts the process toward decay. • clean code does one thing well • Bad code tries to do too much. Grady Booch quote Grady Booch, author of Object Oriented Analysis and Design with Applications \"Clean code is simple and direct. Clean code reads like well-written prose. Clean code never obscures the designer’s intent but rather is full of crisp abstractions and straightforward lines of control.\" notes notes: • a readability perspective • It should contain only what is necessary. Dave Thomas quote “Big” Dave Thomas, founder of OTI, godfather of the Eclipse strategy \"Clean code can be read, and enhanced by a developer other than its original author. It has unit and acceptance tests. It has meaningful names. It provides one way rather than many ways for doing one thing. It has minimal dependencies, which are explicitly defined, and provides a clear and minimal API. Code should be literate since depending on the language, not all necessary information can be expressed clearly in code alone.\" notes notes: • clean code makes it easy for other people to enhance it. • Code without tests, is not clean. • Smaller is better. • literate: the code should be composed in such a form as to make it readable by humans. Michael Feathers quote Michael Feathers, author of Working Effectively with Legacy Code \"I could list all of the qualities that I notice in clean code, but there is one overarching quality that leads to all of them. Clean code always looks like it was written by someone who cares. There is nothing obvious that you can do to make it better. All of those things were thought about by the code’s author, and if you try to imagine improvements, you’re led back to where you are, sitting in appreciation of the code someone left for you—code left by someone who cares deeply about the craft.\" notes notes: • paid appropriate attention to details. Ron Jeffries quote Ron Jeffries, author of Extreme Programming Installed and Extreme Programming Adventures in C#. \"In recent years I begin, and nearly end, with Beck’s rules of simple code. In priority order, simple code: • Runs all the tests; • Contains no duplication; • Expresses all the design ideas that are in the system; • Minimizes the number of entities such as classes, methods, functions, and the like.\" notes notes: • duplication: it’s a sign that there is an idea in our mind that is not well represented in the code. didn't understand that \"however. I also look at whether an object or method is doing more than one thing. If it’s an object, it probably needs to be broken into two or more objects. If it’s a method, I will always use the Extract Method refactoring on it, resulting in one method that says more clearly what it does, and some submethods saying how it is done.\" • all programs are made up of very similar elements. • Reduced duplication, high expressiveness, and early building of simple abstractions. ","date":"2021-08-26","objectID":"/notesforcleancodebook/:1:5","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Professional"],"content":"We Are Authors • We Are Authors: • The next time you write a line of code, remember you are an author, writing for readers who will judge your effort. • there’s no way to write code without reading it, so making it easy to read actually makes it easier to write. ","date":"2021-08-26","objectID":"/notesforcleancodebook/:1:6","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Professional"],"content":"Conclusion • Conclusion: Books on art don’t promise to make you an artist. All they can do is give you some of the tools, techniques, and thought processes that other artists have used. So too this book cannot promise to make you a good programmer. It cannot promise to give you “code-sense.” All it can do is show you the thought processes of good programmers and the tricks, techniques, and tools that they use. ","date":"2021-08-26","objectID":"/notesforcleancodebook/:1:7","series":null,"tags":["Book Notes"],"title":"NotesForCleanCodeBook","uri":"/notesforcleancodebook/"},{"categories":["All","Hobbies"],"content":"this is just some content learing how to highlight: # declaring two variables and printing the sum of the two. x = 1 y = 2 print(x + y) ","date":"2021-08-26","objectID":"/third_post/:0:0","series":null,"tags":["tag3"],"title":"this is the Third_post","uri":"/third_post/"},{"categories":["All","Professional"],"content":"this is some content to test public static void Main(){ Console.WriteLine(\"Hello World from firt post!\"); } this is some content to test print(\"Hello world!!\") ","date":"2021-08-26","objectID":"/first_post/:0:0","series":null,"tags":["tag1"],"title":"this is the first post","uri":"/first_post/"},{"categories":["All","Projects"],"content":"learn how to add an image or figure in a post. Programming is fun The images should be put in the ‘static’ folder. learing how to highlight: # declaring two variables and printing the sum of the two. x = 1 y = 2 print(x + y) just exploring what gist is: Gist is one of the many features GitHub provides to its users. GitHub defines2 a Gist as follows: “Gist is a simple way to share snippets and pastes with others. All Gists are Git repositories, so they are automatically versioned, forkable and usable from Git.” just exploring \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e working wiht showcases: \r\rThis is My first post\r\rjust exploring and discoving more and more about Hugo and its features.\rRead more...\r\r ","date":"2021-08-26","objectID":"/second_post/:0:0","series":null,"tags":["tag2"],"title":"this is the second post","uri":"/second_post/"},{"categories":null,"content":"Hi, I’m Mahmoud Abdallah Hassan, Currently I’m in the last year of college, I study Computer Engingeering and Systems at Faculty of Engineering at Zagazig Univesity. ------------------- This is my first bolg website. So,\rIf you have any suggestion for making this blog better or any edit please contact me i’d like to take the feedback.\r------------------- Education\r\r• Zagazig University Engineer's degree Computer Engineering \u0026 Systems 2018-2022 \r\r\r• Sofia Secondary School High School Diploma 2014-2017 \r\rLicenses \u0026 certifications\r\r\r• Database Fundamentals Issused Aug 2021 Mahara Tech ITIMooca See Credential\r\r\r---------------------- \r• Learn HTML \u0026CSS Issued Jul 2021 Mahara Tech ITIMooca See Credential\r\r\r---------------------- \r• 60 wpm 97.8% accuracy Typing Certificate Issued Jul 2021 Ratatype See Credential\r\r\r---------------------- \r• Python Programming Basics Issued Dec 2020 Mahara Tech ITIMooca See Credential\r\r\r---------------------- \r• Python (Basic) Issued Sep 2020 HackerRank See Credential\r\r\r---------------------- \r• HCIA AI Issued Des 2020. Expires Dec 2023 Huawei See Credential\r\r\r\r","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"About Me","uri":"/about/"}]